
|-|_|-|_|-|_|-|Copying a file or directory keeping the owners and permissions|-|_|-|_|-|_|-|

// copying recursively:
$ cp -rp <origin> <destination>

// Copying a single file:
$ cp -p <origin> <destination>

"p" is for:  --preserve=mode,ownership,timestamps



|-|_|-|_|-|_|-|_|-|_|-|Habilitar o deshabilitar servicios al inicio|-|_|-|_|-|_|-|_|-|_|-|

-/-/-\PARA HABILITAR:
# chkconfig httpd --add
# chkconfig httpd on --level 2,3,5
OR
# chkconfig httpd on
OR
# systemctl enable httpd

-/-/-\PARA DESHABILITAR:
# chkconfig httpd off
OR
# systemctl disable httpd



|-|_|-|_|-|_|-|_|-|_|-|Matar procesos|-|_|-|_|-|_|-|_|-|_|-|

# ps aux | grep -i <pattern>
# kill <PID>

-/-/-\PARA MATAR PROCESO POR PATRON SIMILAR:

# pkill <PID>

Lo anterior SOLO mata procesos del Foreground, NO del Background.
Si se quiere matar un proceso del Background se debe usar la señal SIGKILL
$ kill -s SIGKILL <PID>



|-|_|-|_|-|_|-|_|-|_|-| Rsync |-|_|-|_|-|_|-|_|-|_|-|

#rsync -av <directorio> <destino>

-/-/-\DRY-RUN (SIMULACRO, NO COPIA ARCHIVOS)

#rsync -anv <directorio> <destino>




|-|_|-|_|-|_|-|_|-|_|-|  tr (translate)  |-|_|-|_|-|_|-|_|-|_|-|

# tr -s "h"< file1>file2
---> translates (replace, thanks to the "-s" flag) all the repeating h's in file1 into one single "h" and saves the output in file2.

# cat file1 | tr "[a-m]" "[A-M]">file2
---> finds all the characters from "a" to "m" and turns them into upper case.


|-|_|-|_|-|_|-|_|-|_|-|  TAIL and HEAD  |-|_|-|_|-|_|-|_|-|_|-|

$ tail -n 2 texto.txt
--> prints the 2 last lines of the file

$ tail -n +2 texto.txt
--> prints all lines of the file starting to the second line and omitting the first line

$ head -n 2 texto.txt
--> prints the 2 first lines of the file

$ head -n -2 texto.txt
--> prints all lines of the file omitting the last 2 lines





|-|_|-|_|-|_|-|_|-|_|-|  AWK  |-|_|-|_|-|_|-|_|-|_|-|


$ ls -l | awk '{print $3 " " $5 " " $9}'
---> prints only the thrid, fifth and ninth column of the oputput

$ awk '{print $1, $(NF-1) }' sample.txt
---> prints the first and the second last column of the file

$ ls -1 | awk -F "\t" '{print $1 " - " $1}'
--> We indicate that the columns are separated by tabs. We can specify whatever as a separation, as shown in the next example:

$ ls -1 | awk -F "KKKK" '{print $1 " - " $1}'
--> we indicate that the columns are separated by "KKKK". This is useful when names are made up of tabs and spaces,
	if a name is comprised of tabs and spaces, awk will think that they are separations of columns, so it's important
	to establish another separator format in these cases.
	
$ ls -1 | awk -F "jlkjjh" '{print "\x27" $1 "\x27" " - " "\x27" $1 "\x27"}'
--> '\x27' is used to print simple quotes around the printed expressions. Hex ASCII code has to be used, cause simple quotes cause conflict
	with the simple quotes surrounding the braces of print

$ cat file.txt | awk '/pattern/{print $2}'
---> will print all lines in which "pattern" exists



|-|_|-|_|-|_|-|_|-|_|-|  SED (Stream Editor)  |-|_|-|_|-|_|-|_|-|_|-|

SED filters and transforms text.
SED makes changes to file content.


# cat file1 | sed 's/do/wow/g'>file2
---> replace the word "do" by "wow" globally

# cat file1 | sed 's/do/wow/1'>file2
---> replace the word "do" by "wow" once per line

# cat file1 | sed '1 s/do/wow/'>file2
---> replace the word "do" by "wow" but only in the first line

# cat file1 | sed 's/hola/quiubo/gi'>file2
---> replace the word "hola" by "quiubo" globally in case insensitive mode.

# sed ':a;N;$!ba;s/\b/"/g' file.txt
---> Find all boundaries and replaces them for "

# sed ':a;N;$!ba;s/\n/,/g' file.txt
---> Replaces new lines for commas in file.txt

# sed 's/^\b/"/m' dirs2
---> Replaces start boundary with "

# sed 's/\b$/"/m' dirs2
---> Replaces end boundary with "


One can use another separator different from "/", such as "@", "#", "%".
This is useful for bash not to get confused with "/" in a situation where "/" is part of the string you want to replace

$ sed -e 's@com:@com/@' 
---> It will replace "com:" with "com/"

$ sed -e 's%\.git$%%'
---> It will replace ".git" with "", as long as it is at the end of the line 


One can use regular expressions as well:

sed -E 's#(git@|git://)#https://#'
---> It will replace "git@" or "git://" by "https://"




|-|_|-|_|-|_|-|_|-|_|-|  CUT  |-|_|-|_|-|_|-|_|-|_|-|

cuts portions of text depending on a given delimiter 

$ cut -d "/" -f 3,4 texto.txt
---> sets the "/" character as separator, once the strings are divided it selects the third and fourth strings to print them

$ echo "path/to/file" | cut -d "/" -f 3
---> It will print "file"



|-|_|-|_|-|_|-|_|-|_|list files recursively / list total files or directories inside a directory|-|_|-|_|-|_|-|_|-|_|-


$ find /directory -type f
---> finds files recursively

$ find /directory -type d
---> finds directories recursively

$ find /directory | wc -l
---> find all (files and directories) and list the total number of lines

$ find /directory -maxdepth 1
---> find all (files and directories) only in the root /father directory

$ find /directory -name "*.sql" -type f
---> find all files that have the given name recursively

$ find ./ -size 20M
---> find all files larger than 20MB



|-|_|-|_|-|_|-|_|-|_|-|  Count words, lines and characters of a file  |-|_|-|_|-|_|-|_|-|_|-|

$ wc -m <file>		--> counts characters 
$ wc -l <file>		--> counts lines 
$ wc -w <file>		--> counts words



|-|_|-|_|-|_|-|_|-|_|-|  Find files  |-|_|-|_|-|_|-|_|-|_|-|

--> find directories and files (search only in actual directory) case insensitive:
$ find /directory -maxdepth 1 -iname "*tiqal*"

--> Find recursively only files (excludes directories) Case sensitive:
$ find /directory -name "*tiqal*" -type f

--> Find recursively only directories (excludes files) Case insensitive:
$ find /directory -iname "*tiqal*" -type d

--> Case insensitive (another way):
$ find /directory -print | grep -i tiqal




|-|_|-|_|-|_|-|_|-|_|-|  Remove files recursively  |-|_|-|_|-|_|-|_|-|_|-|

-> First we find the file
$ find /directory -name "*.sql" -type f

--> Once we know the files and we are sure that we can delete them:
$ find /directory -name "*.sql" -type f -delete





|-|_|-|_|-|_|-|_|-|_|-|  mount img files or ISO  |-|_|-|_|-|_|-|_|-|_|-|


mount -o loop,offset=65536 /home/edier88_laptop/Downloads/usb.img /mnt/images/




|-|_|-|_|-|_|-|_|-|_|-|  LVM Tutorial  |-|_|-|_|-|_|-|_|-|_|-|

# vgs
# lvs
# pvs

# pvdisplay	--> physical volume details
# lvdisplay	--> logical volume details
# vgdisplay	--> volume group details



for extending a logical volume, the process has to be done with a liveUSB. It cannot be done in the linux system working.
Tutorial for extending LVM logical volumes:

https://www.tecmint.com/extend-and-reduce-lvms-in-linux/



|-|_|-|_|-|_|-|_|-|_|-|  Sort files by date  |-|_|-|_|-|_|-|_|-|_|-|

# ls -lt

ó de forma reversa:

# ls -ltr

ó usando awk

# ls -l | awk '{print $7,$6,$8,$9}' | sort -n




|-|_|-|_|-|_|-|_|-|_|-|  Sort/list only directories  |-|_|-|_|-|_|-|_|-|_|-|

$ ls -ld

$ ls -lF | grep \/$	---> -F allows us to list directories with a "/" at the end, so we can grep the "/"
	or
$ ls -la | grep ^d	---> To grep all lines with a "d" at the beginning

$ ls -h		---> list files with sizes in a human way



|-|_|-|_|-|_|-|_|-|  mimeinfo - default applications for file types  |-|_|-|_|-|_|-|_|-|

/usr/share/applications/mimeinfo.cache

Por ejemplo para eliminar que Chrome/Chromium se abra por defecto al abrir archivos PHP se borra la linea: 

x-scheme-handler/ftp=google-chrome.desktop;



|-|_|-|_|-|_|-|_|-|  Compresión y decompresión en TAR GZ  |-|_|-|_|-|_|-|_|-|

f --> specifies file name
t --> lists all contained files in the tar file
z --> use gzip compression/decompression
j --> use bzip2 compression/decompression method
x --> extracts the file
c --> compresses the file
C --> allows you to save the extracted stuff to the directory you want



tar -czvf <compressedFileName.tar.gz> <directory or file you want to compress>
tar -xzvf <compressedFileName.tar.gz> -C <directory where you want to allocate the uncompress files>

or

tar -cjvf <compressedFileName.tar.bz2> <directory or file you want to compress>
tar -xjvf <compressedFileName.tar.bz2> -C <directory where you want to allocate the uncompressed files>



|-|_|-|_|-|_|-|_|-|  Zip compression decompression  |-|_|-|_|-|_|-|_|-|

$ zip <compressed_file_name> <files_to_compress>
$ zip -r <compressed_file_name> <directory_to_compress>	--> compress directory recursively
$ zip -0 -r <compressed_file_name> <directory_to_compress>	--> compression level (0 to 9), 0 means no compression at all, only store
$ zip -e -r <compressed_file_name> <directory_to_compress>	--> e flag, create password protected zip files

$ unzip <zip_file_name>				--> unzip files
$ unzip <zip_file_name> -d <directory_name>		--> unzip files to a directory, if it doesn't exist it will be created
$ unzip -o <zip_file_name>				--> overwrite uncompressed files if exists
$ unzip -n <zip_file_name>				--> incremental unzipping, only unzips what doesn't exist
$ unzip -l <zip_file_name> | less			--> looks inside a zip file

$ zipdetails <zip_file_name> | less			--> length, flags, filename, access time

$ zipgrep <term_to_find> <zip_file_name>		--> find files inside the zip file

$ zipinfo <zip_file_name> | less			--> file permissions, original file size, time stamp, compression method, etc.

$ zipsplit -n 102400 <zip_file_name>				--> split/divide an existing zip file into parts of 102400 bytes



|-|_|-|_|-|_|-|_|-|  link and unlink directory or files  |-|_|-|_|-|_|-|_|-|

---> Hard Link:
$ ln <originalFile> <newfile-hardlinked>
I create a hard link (a file associated physicaly to the inode of "originalFile")
To view the inodes of the files:
$ ls -li
The inodes of both files must be the same.

Example: (if I make a hard link I can be sure of having created it if when I issue "ls -li" it appears two file with the same inode number)
​$ ln file1 file2
$ ls -li file1 file2
84 -rw-rw-r-- 2 coop coop 1551 Jun 16 16:28 file1
84 -rw-rw-r-- 2 coop coop 1551 Jun 16 16:28 file2
^
|
|
|
This is the inode number, if two files have identical inode number, it means that one is the hard link of the other.
The Inode number is unique, so if two files have identical inode number, it means that a Hard link has been made




---> Symbolic Link:
$ ln -s <archivo o directorio> 
El link simbólico se guardaría en el directorio donde uno esté, si se quiere poner un nombre:
$ ln -s <archivo o directorio> <name_symlink>


---> Unlink:
$ unlink <nombre del symlink>

- To list all symbolic links inside a directory:
$ symlinks -rv /etc



|-|_|-|_|-|_|-|_|-|  GREP or EGREP - Mark matched patterns  |-|_|-|_|-|_|-|_|-|

- Case insensitive search:
$ grep -i <pattern>

- Invert match, shows all lines that do not match with the pattern:
$ grep -v <pattern>

- Counts all the matches 
$grep -c <pattern>

- Displays all lines but highlights the match pattern:
$ grep -z <pattern>

- Displays the lines you want after and before the matched pattern
$ grep -A <number of lines before> -B <number of lines after> <pattern>

Example: This shows 10 lines before and 7 lines after the matche pattern:
$ grep -A 10 -B 7 <pattern>

Search in the current directory (recursively and case insensitive) all the files that contain a pattern inside them:
$ grep -Ri <pattern> /directory

Search a string with regular expressions: (This will search 'hola:lola' or 'hola : lola' or 'hola :lola' etc.)
$ egrep -r 'hola\s*\:\s*lola'
(if case insensitive is needed, the flag '-i' must be added)

Find all lines with "textA" but without the word "textB" (-v excludes the coincidence)
$grep -iR textA . | grep -v textB



|-|_|-|_|-|_|-|_|-|  SERVIDOR UBUNTU 10.04 FEBRICIO - COMANDOS Y RUTAS DISPOSITIVOS DE RED  |-|_|-|_|-|_|-|_|-|

- Para ver los dispositivos instalados:
# ls /sys/class/net
# cat /proc/net/dev   --->  (algo así)

El programa Wispro configura los dispositivos, las IP's y las rutas de una forma que, por ejemplo, en /etc/sysconfig, no se encuentra configurado absolutamente nada.

- Para levantar la interfaz nueva, que se creó en la interfaz web de Wispro, se usó:
# sudo ip link set dev eth0 down
De esa manera, al usar "ifconfig" ya se veía la interfaz nueva.

- Adicionalmente en: "/etc/network/interfaces"  se puede configurar la ip estática de una interfaz en particular adicionando la IP de manera similar a esta:

auto eth0
iface eth0 inet static
address 192.168.1.2
netmask 255.255.255.0
broadcast 
gateway 192.168.1.1

- Si es por DHC:

auto eth0
iface eth0 inet dhcp


- En "/etc/resolv.conf"  van los DNS:

nameserver 8.8.8.8
nameserver 8.8.4.4


|-|_|-|_|-|_|-|_|-|  DNF History - show removed and installed packages  |-|_|-|_|-|_|-|_|-|

# dnf history list		---> List of all dnf commands issued, all the command have an ID

# dnf history info <id>	---> Lists all the installed and removed packages due to a specific dnf command identified by its ID.




|-|_|-|_|-|_|-|_|-|  PATH environment variables  |-|_|-|_|-|_|-|_|-|

The PATH keeps all the routes of the files that conatain the binaries that makes all commands in Linux: mv, cp, mkdir, etc...
When a new command needs to be issued in the terminal, due to a new program, for example Laravel. The PATH has to be updated with the route of the binary that program has to use.

To show the paths already configured:
$ $PATH

To add another path, we need to enter in terminal this command:
$ export PATH="/<directory>/<route>/<to>/<bin>:$PATH"
For example:
$ export PATH="$HOME/.config/composer/vendor/bin:$PATH"

However, if we issue this command in Terminal, as soon as we restart the machine or the terminal it self, all paths added disappear. 
For adding permanently paths, we need to write this:
export PATH="/<directory>/<route>/<to>/<bin>:$PATH"
At the end of the following files:
/etc/profile
~/.bash_profile
~/.bashrc
~/.profile
The files can be found in both, the root directory or the normal users directory. The file you need to edit depends on where you want the path to be permanently added and on what terminal emulator you're working in (bash or zsh or others).


FOR ENVIRONMENT VARIABLES:

Just add in:
/etc/profile
or
~/.bash_profile
or
~/.bashrc
or
~/.profile

The name of the variable and its value, like this:
export MY_VARIABLE="my_value"


|-|_|-|_|-|_|-|_|-|  Show devices and filesystems sizes / available space  |-|_|-|_|-|_|-|_|-|

$ df -h


|-|_|-|_|-|_|-|_|-|  Show file sizes in a directory  |-|_|-|_|-|_|-|_|-|

$ du -h				---> Lists the sizes of only directories
$ du -ah				---> Lists the sizes of directories and files recursively
$ du -ah --max-depth=1			---> Lists the sizes of directories and files up to one level
$ du -ah --max-depth=1	| sort -h	---> Lists the sizes of directories and files up to one level and sorts the list in ascending order
$ du -ah --max-depth=1	| sort -hr	---> Lists the sizes of directories and files up to one level and sorts the list in descending order


|-|_|-|_|-|_|-|_|-|  Show what's inside a file  |-|_|-|_|-|_|-|_|-|

$ cat <fileName>
$ tail <fileName>
$ head <fileName>
$ tail -5 <fileName>		---> Shows last 5 lines
$ head -5 <fileName>		---> Shows first 5 lines


|-|_|-|_|-|_|-|_|-|  Using watch to see a file changing in real time  |-|_|-|_|-|_|-|_|-|

$ watch tail error.log			--> watch last lines of 'error.log'
$ watch tail -n 1 error.log		--> watch the last line of 'error.log'



|-|_|-|_|-|_|-|_|-|  Environment Variables  |-|_|-|_|-|_|-|_|-|

HOME		---> Home directory of local user
MAIL		---> Contains the messages of received mails
PATH		---> It saves the executable commands and programs
SHLVL		---> Registra niveles de shell anidado
SHELL		---> Name of the type of the shell being used
LANG		---> It saves the local language used at the moment
USER		---> Contains the name of user


|-|_|-|_|-|_|-|_|-|  Users and groups management  |-|_|-|_|-|_|-|_|-|

/etc/passwd			---> users
/etc/group			---> groups

--->Users
# useradd <userName>		---> Creates user
# useradd -m <userName>		---> Creates the user and its directory in /home
# passwd <userName>		---> Sets password to user
# userdel <user>		---> Removes a user
# userdel -r <user>		---> Removes a user with its home directory
# adduser <userName> sudo	---> Adds the user to the sudoers file
# usermod -aG wheel <userName>	---> Adds the user to the sudoers file


--->Groups
# groupadd <groupName>				---> Creates group
# groupel <groupName>				---> Removes group
# usermod -aG <group> <user>			---> adds an existing user to a group
# usermod -aG <group1,group2,group3> <user>	---> adds an existing user to various groups
# adduser -g <group> <user>			---> Creates a new user and adds it to a group
# gpasswd -d <username> <groupname>		---> Removes a user from a group

- In the directory /etc/skel/ is located all directories and files that will be created in the new user directory upon its creation.

- Block or unblock users

# usermod --lock <username>	---> In /etc/shadow one can see a "!" after the username. It means the user is blocked
# usermod --unlock <username>

- After adding a user to a new group, it needs to log in to the new group, that can be done this way:
$ newgrp <group_name>			--> logs the user (that is using the terminal) in the new group

$groups					--> Shows what groups the logged in user belongs to


|-|_|-|_|-|_|-|_|-|  Change owner and permissions  |-|_|-|_|-|_|-|_|-|

# chown -R <user>:<group> /directory/
# chmod -R 777 /directory/	---> rwxrwxrwx



|-|_|-|_|-|_|-|_|-|  Execution levels  |-|_|-|_|-|_|-|_|-|

$ runlevel 		--> That way we can know in which level are we running our system

- Execution levels:

0 - Shut down any system
1 - Monouser mode
2 - Multiuser mode
3 - Multiuser mode with network capabilities
4 - ( -- This level has been eliminated, it no longer exists, as it does the same thing as the level 3 -- )
5 - Multiuser with GUI and network capabilities
6- Restart any service



|-|_|-|_|-|_|-|_|-|  Systemctl - Systemd  |-|_|-|_|-|_|-|_|-|

# systemctl reload <service>		--> It reloads only the configuration file of a service, instead the whole service (not all services support this)

# systemctl enable <service>
# systemctl disable <service>		--> It disables / enables a service to start at startup

# systemctl isenable <service>	--> Says if the service is enabled at startup or not

# systemctl list-units --type=service --state=running	--> Lists all running services (started services)
# systemctl list-unit-files					--> lists ALL the installed services



# systemctl list-unit-files --state=enabled			--> Lists all services which will start at system startup
# systemctl list-unit-files --state=disabled			--> Lists all services which won't start at system startup



|-|_|-|_|-|_|-|_|-|  Free SSL certificates  |-|_|-|_|-|_|-|_|-|

Free SSL certificates with Certbot and Let's Encrypt



|-|_|-|_|-|_|-|_|-|  Show Hardware configuration  |-|_|-|_|-|_|-|_|-|

$ lspci

$ lshw

$ neofetch		--> Very Nice, Beautiful and brief configuration
$ screenfetch





|-|_|-|_|-|_|-|_|-|  Add icon in applications list Gnome  |-|_|-|_|-|_|-|_|-|

After installing a third party program we need to create a file with in the following directory and the following convention:
 ~/.local/share/applications/<programName>.desktop
The file has to contain something like the following example based in Postman program:
(source: https://linux4one.com/how-to-install-postman-in-linux/)

[Desktop Entry]
Name=Postman
GenericName=API Client
X-GNOME-FullName=Postman API Client
Comment=Make and view REST API calls and responses
Keywords=api;
Exec=/opt/Postman/Postman
Terminal=false
Type=Application
Icon=/opt/Postman/app/resources/app/assets/icon.png
Categories=Development;Utilities;




|-|_|-|_|-|_|-|_|-|  Special permissions (setuid & setgid)  |-|_|-|_|-|_|-|_|-|

--> setuid
For example:
ls -l /bin/passwd
-rwsr-xr-x. 1 root root 27768 Feb 11  2017 /bin/passwd

The setuid only works for files, not for directories. When any user different from the one who executed the file, executes the file, it is executed as if the owner were executing it. That's because, the file is always executed with the owner's user ID, no matter who executes it.



--> setgid
For example:
$ ls -ld test
drwxrwsr-x. 2 egdoc egdoc 4096 Nov  1 17:25 test

The setgid has effect in directories and files, when any user executes the files, this is executed with the group permissions, no matter if the user who executed it doesn't belong to that group.


If we have a file called "test", implementing this with "chmod" command, would be:

1. For setuid:
$ chmod 4775 test

2. For setgid:
$ chmod 2775 test



|-|_|-|_|-|_|-|_|-|  Additional permissions |-|_|-|_|-|_|-|_|-|

    + (plus) suffix indicates an access control list that can control additional permissions.
    . (dot) suffix indicates an SELinux context is present. Details may be listed with the command ls -Z.
    @ suffix indicates extended file attributes are present.





|-|_|-|_|-|_|-|_|-|  Special permissions (sticky bit, SUID, SGUID)  |-|_|-|_|-|_|-|_|-|

    setuid = 4
    setgid = 2
    sticky = 1


--- STICKY BIT:

Sticky bit can be only applied to directories. 
Given a directory called "test" we can give it a sticky bit this way:

$ chmod 1775 test/

Sticky bit prevents users of modifying or deleting files inside a directory, no matter if the files inside there has all the permissions.
For example:

- I make the directory "allAccess" and put a sticky bit on it:
$ mkdir allAccess
$ chmod 1777 allAccess/
$ ls -ld allAccess/
drwxrwxrwt 2 himanshu himanshu 4096 Oct 24 15:43 allAccess/

- If different users inside the directory create different files, like this:

$ ls -l allAccess/
total 0
-rwxrwxrwx 1 himanshu himanshu 0 Oct 24 15:48 file1
-rwxrwxrwx 1 guest    guest    0 Oct 24 16:11 file2
-rwxrwxrwx 1 guest2   guest2  0 Oct 24 16:15 file3

- And "guest2" wants to modify "file2", an error will be displayed. Thanks to the sticky bit in the directory, ONLY and ONLY the owner of the file can modify it or remove it.


To deactivate sticky bit, just change permissions this way: 
$ chmod 0777 <directory>



--- SUID:

Cuando se activa el bit SUID sobre un fichero significa que el que lo ejecute va a tener los mismos permisos que el que creó el archivo. Esto es útil en algunas ocasiones, aunque hay que utilizarlo con cuidado, ya que puede acarrear problemas de seguridad

Para activarlo:

$ chmod 4775 hello.sh
$ ls -l hello.sh

-rwsrwxr-x 1 david david 26 Jun 11 19:02 hello.sh

$ chmod -x hello.sh
$ ls -l hello.sh

-rwSrw-r-- 1 david david 26 Jun 12 19:02 hello.sh

Observamos que en la última línea le quitamos el servicio de ejecución al archivo y en los permisos se reemplaza la s minúscula por la S mayúsculas.


--- SGID:

El bit SGID es lo mismo que SUID, pero a nivel de grupo. Esto es, todo archivo que tenga activo el SGID, al ser ejecutado, tendrás los privilegios del grupo al que pertenece.

Opción bastante útil si queremos configurar un directorio para colaborar diferentes usuarios. Si se aplica este bit al directorio, cualquier archivo creado en dicho directorio, tendrá asignado el grupo al que pertenece el directorio

Por ejemplo, si un usuario que tiene permiso de escritura en el directorio crea un archivo allí, ese archivo es un miembro del mismo grupo que el directorio y no el grupo del usuario. Como hemos dicho, esto es muy útil en la creación de directorios compartidos.

$ chmod g+s "directorio"

En el caso de un fichero:

$ chmod 2555 "fichero"



More information:
https://fedoramagazine.org/command-line-quick-tips-more-about-permissions/



|-|_|-|_|-|_|-|_|-| Inserting some bash: Some commands explanations |-|_|-|_|-|_|-|_|-|

$ find /var/www/html/wordpress -type d -exec chmod g+s {} \;

The "exec" commprand simply executes what is in front of it when any directory is found:

Example 1:
$ find . -type f -exec chmod 775 {} \;
Output:
chmod 775 fileA
chmod 775 fileB
chmod 775 fileC


Example 2:
$ find . -type f -exec chmod 775 {} + 
Output:
chmod 775 fileA fileB fileC




|-|_|-|_|-|_|-|_|-| Cut, trim videos with ffmpeg |-|_|-|_|-|_|-|_|-|

$ ffmpeg -i <video> -ss 00:00:02 -to 00:07:30 -c copy <video_output>

I have only used this with MKV videos.

-ss : With this flag one specifies where to cut (everything before this time will be discarded)
-to : This flag specifies the finishing cut (everything after this time is discarded)

This example will generate a video with a duration of 7 minutes and 28 seconds, starting in the second "2" of the original video and ending in the minute 07:30 of the original video.



|-|_|-|_|-|_|-|_|-| Convert videos with Handbrake |-|_|-|_|-|_|-|_|-|

Convert videos with Handbrake so that they are compatible with all devices (mp4 extension is preferred)



|-|_|-|_|-|_|-|_|-| Open files and directories in Nautilus using the Terminal |-|_|-|_|-|_|-|_|-|

xdg-open
gnome-open


|-|_|-|_|-|_|-|_|-| Transfer files with Rsync via SSH |-|_|-|_|-|_|-|_|-|

- Copying files:
rsync foo.txt me@server:/home/me/

- Copying directories:
rsync -r bar/ me@server:/home/me/



|-|_|-|_|-|_|-|_|-| Connect to other host via SSH |-|_|-|_|-|_|-|_|-|


$ ssh <remote_host>
$ ssh <remote_username>@<remote_host>


|-|_|-|_|-|_|-|_|-| NMAP - Ports and network scanning |-|_|-|_|-|_|-|_|-|

$ nmap -p 636 10.29.114.230	--> It looks for the port "636" (ldap) in the remote IP 10.29.114.230

$ nmap -sn 192.168.1.0/24	--> Scans all the hosts up in the ip address segment




|-|_|-|_|-|_|-| NETSTAT - View listening connections in our server (ip address:port) |-|_|-|_|-|_|-|

netstat prints network connections, routing tables, interface statistics, masquerade connections, and multicast memberships

$ netstat -tlnp

-t	--> TCP connections
-l	--> show listening connections
-n	--> numeric
-p	--> order by program



|-|_|-|_|-|_|-|_|-| Modules in Linux Kernel |-|_|-|_|-|_|-|_|-|

- list the status of all modules:
$ lsmod

- See the information of particular driver:
$ modinfo {driver-name}

- Add and remove modules from the Linux Kernel:
# modprobe


|-|_|-|_|-|_|-|_|-| Formatting devices |-|_|-|_|-|_|-|_|-|

# mkfs.ntfs -f -L <USB_name> /dev/sdaX
# mkfs.vfat -F 32 -n "<USB_name>" /dev/sdaX



|-|_|-|_|-|_|-|_|-| List available repositories, enable them and disable them |-|_|-|_|-|_|-|_|-|

# dnf repolist
# dnf repolist all

-- Add repository by url:
# dnf config-manager --add-repo http://www.example.com/example.repo


-- Enable or disable repositories
# dnf config-manager --set-enabled repository_name
# dnf config-manager --set-disabled repository_name

-- Create repository:
repositories are stored in /etc/yum.repos.d
it is also possible to create a file called <reponame>.repo  in that directory and enable it



|-|_|-|_|-|_|-|_|-| Making aliases |-|_|-|_|-|_|-|_|-|

$ alias			--> lists all the aliases set
$ alias <word>='<command>'	--> creates an alias (temporary, when terminal closes, it gets removed)
$ unalias <alias_name>		--> removes an alias

If you want to store an alias in your machine forever, you just need to:
1. Create aliases for your user in ~/.bashrc
OR
2. Create aliases for everyone in /etc/bash.bashrc

alias <word>='<command>'

3. Activate alias by typing: 
$ source ~/.bashrc


|-|_|-|_|-|_|-|_|-| Starting, stopping, disabling, enabling Services at startup |-|_|-|_|-|_|-|_|-|

# systemctl start <service>
# systemctl stop <service>
# systemctl enable <service>
# systemctl disable <service>




|-|_|-|_|-|_|-|_|-| Red Hat listing and installing modules|-|_|-|_|-|_|-|_|-|

# dnf module list | grep -i postgresql	--> We list all the modules containing the word postgresql

# yum module install postgresql:12/client	--> We install the module postgresql, Stream "12", profile "client"



|-|_|-|_|-|_|-|_|-| RPM AND DNF COMMANDS |-|_|-|_|-|_|-|_|-|

- Install a package:
# rpm -i foo.rpm

- Remove a package:
# rpm -e foo.rpm

- Update package to a newer version:
# rpm -U foo.rpm

- Show all installed packages: 
# rpm -qa
# dnf list installed

- Get information about an installed package including files:
# rpm -qil foo

- Show available packages with "foo" in name: 
# dnf list foo

- Show all available packages: 
# dnf list

- What package does a file belong to? 
# rpm -qf file

- What does a package provides? 
# rpm -q --whatprovides <package>

- What packages are using a specific package? 
# rpm -q --whatrequires <package>




|-|_|-|_|-|_|-|_|-| RPM PACKAGING |-|_|-|_|-|_|-|_|-|

lists files and directories of an installed package
$ sudo dnf repoquery -l fpaste
$ rpm -ql fpaste


what does a package require. (Dependencies)
rpm -q --requires fpaste
sudo repoquery --whatrequires python3


- what does a package provide
rpm -q --provides fpaste


`fpaste --sysinfo`
rpm -qi fpaste
sudo dnf info fpaste



fedpkg:
the clone is:
fedpkg clone --anonymous <packageName>
??
`fedpkg sources` --> let's download the sources
`tar -xvf fpaste-0.4.2.0.tar.gz`

rpmbuild -ba ./fpaste.spec



|-|_|-|_|-|_|-|_|-| REMOVE CACHE FROM JOURNAL LOGS |-|_|-|_|-|_|-|_|-|

If journal gets too big and uses all the space of the disk, and one doesn't care about removing those logs. One can remove them getting inside /var/log/journal and remove everything.

# rm -rf /var/log/journal/*

Journal generates logs of Kernel, daemons, services and other stuff.
The following command can be used to navigate through the different logs and dates of thos logs:

# journalctl

For more information about the different options and flags of the command, surf the web.



|-|_|-|_|-|_|-|_|-| JOURNALCTL |-|_|-|_|-|_|-|_|-|

# journalctl -u <service-name>
# journalctl -n <last_number_of_lines>

# journalctl 1 | tail -10
# journalctl 1 | head -5


|-|_|-|_|-|_|-|_|-| FLATPAK |-|_|-|_|-|_|-|_|-|

$ flatpak search gimp
$ flatpak install flathub org.gimp.GIMP
$ flatpak list --app
$ flatpak uninstall org.gimp.GIMP
$ flatpak list
$ flatpak update



|-|_|-|_|-|_|-|_|-| FLATPAK FILE SYSTEM PERMISSIONS |-|_|-|_|-|_|-|_|-|

To tell a package to see and recognize a particular directory which it does not find or does not have access to:

$ flatpak override --filesystem=/mnt com.snes9x.Snes9x
$ flatpak override --filesystem=/mnt org.slsknet.SoulseekQt


|-|_|-|_|-|_|-|_|-| LOOK FOR DEPENDENCIES IN INSTALLED PACKAGES |-|_|-|_|-|_|-|_|-|

If we need to know if a package has been installed/compiled with some dependencies, or we want to know if a specific package depends of another specific package, we can use LDD. For example:

$ ldd /usr/bin/icecast | grep -i ssl

The output will be something like:     libssl.so.1.1 => /lib64/libssl.so.1.1 (0x00007fc9f522e000)

In this case, I will be sure that ICECAST was compiled with SSL capabilities.



|-|_|-|_|-|_|-|_|-| LIST DRIVES, PARTITIONS AND UID |-|_|-|_|-|_|-|_|-|

$ lsblk
$ lsblk -f
$ blkid



|-|_|-|_|-|_|-|_|-| CHANGE ENCODING OF FILES |-|_|-|_|-|_|-|_|-|

- To know which format a file has:
$ file -i <filename>

- To convert the encoding of a file:
$ iconv -f <existing file format> -t <format to convert> <file input> <file output>
$ iconv -f iso-8859-1 -t UTF-8//TRANSLIT playlist.log -o playlist.log2

- Ejemplo para convertir el STDOUT al formato deseado:
$ tail -n 1 <file name> | iconv -f <source format> -t <output format>



|-|_|-|_|-|_|-|_|-| STDOUT STDERR with >, >>, 1>, 1>>, 2>, 2>>, &>, &>> |-|_|-|_|-|_|-|_|-|


$ ls -l /etc/directory > filename.txt		--> saves the stdout in filename.txt
$ ls -l /etc/directory >> filename.txt		--> appends the stdout in the next lines of filename.txt

$ ls -l /etc/directory 2> filename.txt		--> saves the stderr in the next lines of filename.txt
$ ls -l /etc/directory 2>> filename.txt		--> appends the stderr in the next lines of filename.txt

$ ls -l /etc/directory &> filename.txt		--> saves the stderr and stdout in the next lines of filename.txt
$ ls -l /etc/directory &>> filename.txt		--> appends the stderr and stdout in the next lines of filename.txt

'1>'		--> It's the same as '>'
'1>>'		--> It's the same as '>>'

An example in Crontab: (redirects STDOUT and STDERR to /var/log/daily-backup.log)

 0 15 * * *    /home/andrew/daily-backup.sh >> /var/log/daily-backup.log 2>&1



|-|_|-|_|-|_|-|_|-| Show file/direcory statistics, settings, information and configuration |-|_|-|_|-|_|-|_|-|

$ stat <filename>




|-|_|-|_|-|_|-|_|-| Remove Cache |-|_|-|_|-|_|-|_|-|

# dnf clean dbcache
	Removes cache files generated from the repository metadata. This forces DNF to regenerate the cache files the next time it is run.

# dnf clean expire-cache
	Removes local cookie files saying when the metadata and mirrorlists were downloaded for each repo. DNF will re-validate the cache for each repo the next time it is used.

# dnf clean metadata
	Removes repository metadata. Those are the files which DNF uses to determine the remote availability of packages. Using this option will make DNF download all the metadata the next time it is run.

# dnf clean packages
	Removes any cached packages from the system.

# dnf clean plugins
	Tells all enabled plugins to eliminate their cached data.

# dnf clean all
	Does all of the above.


|-|_|-|_|-|_|-|_|-| How many Bytes does a sector represent?? |-|_|-|_|-|_|-|_|-|

$ parted /dev/sdc unit s print

Model: sobetter EXT (scsi)
Disk /dev/sdc: 1953525168s
Sector size (logical/physical): 512B/4096B
Partition Table: gpt
Disk Flags: 

Number  Start  End          Size         File system  Name  Flags
 1      2048s  1953525134s  1953523087s  ntfs               msftdata


--- In this example, 1 sector is 512B (logical). 
Because the total size (1953523087) multiplied by 512B is 1.000.203.821.000B. That is 1TB. And the hard disk of the example is indeed a 1TB hard disk.
So, if one needs to know how many Bytes represents a given number of sectors, one needs to multiply the sectors by 512 Bytes.
(at least for this hard drive, that relation depends on the hard drive. So it is recommended to always issue the "parted" command to every hard drive).


|-|_|-|_|-|_|-|_|-| Use Nautilus (File Browser called "Files") as root in Gnome |-|_|-|_|-|_|-|_|-|


1. Open the File Browser and type Ctrl + L
2. type "admin://"
3. Explore filesystem as if you were root.




|-|_|-|_|-|_|-|_|-| CTRL+W para cortar texto   CTRL+Y para pegar texto |-|_|-|_|-|_|-|_|-|

CTRL+W 		para cortar texto
CTRL+Y 		para pegar texto



|-|_|-|_|-|_|-|_|-| cat <<EOF |-|_|-|_|-|_|-|_|-|

It is used to pass multi-line as a single string, example: (the following will create "example.txt" and append all the text below to the recently created text file, until "EOF" is encountered)

$ cat <<EOF > example.txt
#!/bin/bash
echo \$PWD
echo $PWD
EOF

-- OR --

$ cat <<EOF | tee example.txt
#!/bin/bash
echo \$PWD
echo $PWD
EOF


It is mandatory to finish the lines always with "EOF"


|-|_|-|_|-|_|-|_|-| at command - to queue, examine, or delete jobs for later execution |-|_|-|_|-|_|-|_|-|

# at -m -f myjobs.txt now + 10 minutes


|-|_|-|_|-|_|-|_|-| Set default option to boot in Grub 2 |-|_|-|_|-|_|-|_|-|

# grub2-set-default 4

|-|_|-|_|-|_|-|_|-| Locate/find Files (usually configuration files) |-|_|-|_|-|_|-|_|-|

# locate <filename>
Example:
# locate php.ini


|-|_|-|_|-|_|-|_|-| Linux Directories |-|_|-|_|-|_|-|_|-|

/ 		Primary directory of the entire file system hierarchy.
/bin 		Essential executable programs that must be available in single user mode.
/boot 		Files needed to boot the system, such as the kernel, initrd or initramfs images, and boot configuration files and bootloader programs.
/dev 		Device nodes, used to interact with hardware and software devices.
/etc 		System-wide configuration files.
/home 		User home directories including personal settings, files, etc.
/lib 		Libraries required by executable binaries in /bin and /sbin.
/lib64 		64-bit libraries required by executable binaries in /bin and /sbin, for systems which can run both 32-bit and 64-bit programs.
/media 		Mount points for removable media such as CDs, DVDs, USB sticks, etc.
/mnt 		Temporarily mounted filesystems.
/opt 		Optional application software packages. (commonly software that does not install using the standard Linux File Hierarchy)
/proc 		Virtual pseudo-filesystem giving information about the system and processes running on it. Can be used to alter system parameters.
/sys 		Virtual pseudo-filesystem giving information about the system and processes running on it. Can be used to alter system parameters. Similar to a device tree and is part of the Unified Device Model.
/run 		System information data describing the system since it was booted. Should be cleared at every reboot.
/root 		Home directory for the root user.
/sbin 		Essential system binaries.
/srv 		Site-specific data served up by the system (seldom used)
/tmp 		Temporary files; on many distributions lost across a reboot and may be a ramdisk in memory.
/usr 		Multi-user applications, utilities and data; theoretically read-only.
/var 		Variable data that changes during system operation. (logs for example)


|-|_|-|_|-|_|-|_|-| Display memory available - used - total |-|_|-|_|-|_|-|_|-|

$ free -mt
OR
$ cat /proc/meminfo
OR (for swap)
$ cat /proc/swaps

- To free cache memory (data of applications saved in cache):

$ sudo su
# echo 3 > /proc/sys/vm/drop_caches
# exit
$ free -mt

NOTE:
	echo 1 --> empties ALL the cache memory (dentries, inodes and pageCache)
	echo 2 --> empties dentries and inodes
	echo 3 --> empties only pageCache



|-|_|-|_|-|_|-|_|-| Inodes, Dentries, PageCache |-|_|-|_|-|_|-|_|-|

- Inode: 	Identifiers of files
- Dentry: 	Identifier of file structures (complete recursive directories)
- PageCache:	Data that is relevant for apps



|-|_|-|_|-|_|-|_|-| view logs |-|_|-|_|-|_|-|_|-|

$ dmesg -w


|-|_|-|_|-|_|-|_|-| bootable USB with dd |-|_|-|_|-|_|-|_|-|

WARNING: This will erase ALL in USB stick

# dd if=/path/to/iso/file.iso of=/dev/sdX bs=8M status=progress oflag=direct
# dd if=/path/to/iso/file.iso of=/dev/sdX bs=1M status=progress


|-|_|-|_|-|_|-|_|-| Reinstalling GRUB in BTRFS |-|_|-|_|-|_|-|_|-|

PARA REINSTALAR GRUB EN BTRFS:

https://fedoramagazine.org/os-chroot-101-covering-btrfs-subvolumes/
https://fedoraproject.org/wiki/GRUB_2#Reinstalling_GRUB
https://ask.fedoraproject.org/t/grub2-mkconfig-and-btrfs-boot/17533/3

Primero: Ingresar un Live-usb e ingresar al sistema por medio de chroot.

Segundo(para sistemas UEFI):
Remove the following files:
# rm /boot/efi/EFI/fedora/grub.cfg
# rm /boot/grub2/grub.cfg
Reinstall the following packages:
# dnf reinstall shim-* grub2-efi-* grub2-common

Tercero:
# grub2-mkconfig -o /etc/grub2.cfg
# grub2-mkconfig -o /etc/grub2-efi.cfg 

That fixed the issue.


|-|_|-|_|-|_|-|_|-| Download files from remote server |-|_|-|_|-|_|-|_|-|

$ rsync -Wav -e 'ssh' <user>@<ip_address>:/server/file /client/directory/
OR IN A DIFFERENT PORT
$ rsync -Wav -e 'ssh -p 7022' <user>@<ip_address>:/server/file /client/directory/
OR AUTHENTICATING WITH A KEY STORED DIFFERENTLY FROM /.ssh
$ rsync -Wav -e 'ssh -i /path/to/key.pub' <user>@<ip_address>:/server/file /client/directory/
Example:
$ rsync -Wav -e 'ssh' root@147.182.178.11:/music/song.mp3 /home/edier88/Music/

|-|_|-|_|-|_|-|_|-| Connect via SSH to a server |-|_|-|_|-|_|-|_|-|

$ ssh <user>@<ip_address>
CONNECTING WITH A DIFFERENT PORT
$ ssh -p 7022 <user>@<ip_address>
AUTHENTICATING WITH RSA KEYS IN ADIFFERENT LOCATION THAN /.ssh
$ ssh -i /path/to/key.pub <user>@<ip_address>


|-|_|-|_|-|_|-|_|-| Configure PPPoE connection |-|_|-|_|-|_|-|_|-|

$ nmcli con edit type pppoe con-name "PPPoE"

An interactive mode will appear, enter the following lines:
(Instead of "login_username" - we indicate the username specified in the contract.)
nmcli> set pppoe.username <login_username>
nmcli> save
nmcli> quit

2. Go to the "Options" — "Network" menu. In the PPPoE connection, press the gear.
3. In the "General" tab, check the "Connect automatically with priority".
4. In the "Password" field, enter the password from the agreement. 
5. Next, go to the "PPP Settings" tab. Click the "Configure Methods..." button.
6. In the window that appears, uncheck all the boxes except "CHAP". Click the "OK" button.
7. Next, go to the "IPv4 Settings" tab. In the "Method" option, select "Automatic (PPPoE)".
8. We save the changes by clicking the "Save" button.
If you have changed the equipment where the Internet cable was connected, you must tell the support operator the MAC address of the new device.


|-|_|-|_|-|_|-|_|-| Change Favorite/Pinned apps in Dash via Command Line |-|_|-|_|-|_|-|_|-|

you should know the .desktop file names of your applications..
If you don't know them, issue:

$ gsettings get org.gnome.shell favorite-apps

Then set the apps you want. Example:

$ gsettings set org.gnome.shell favorite-apps "['chromium-browser.desktop', 'google-chrome.desktop', 'org.gnome.Nautilus.desktop', 'org.gnome.Software.desktop', 'audacious.desktop', 'mpv.desktop', 'spotify_spotify.desktop', 'org.gnome.Terminal.desktop', 'libreoffice-writer.desktop', 'gnome-calculator_gnome-calculator.desktop', 'libreoffice-calc.desktop', 'gnome-control-center.desktop', 'org.gnome.tweaks.desktop', 'firefox.desktop']"

what ever order you will give in gsettings command, it will have same order in dash-to-dock



|-|_|-|_|-|_|-|_|-| Execute commands in one line |-|_|-|_|-|_|-|_|-|

- The commands will execute one after the other in one process:
$ ls; mkdir hola; cal

- The commands will execute independently, each one in a single process (PID):
$ ls & date & cal

- The second command will execute if the first does not throw errors: (AND operators)
$ mkdir test && cd test

- The second command will execute, no matter if the first throws errors: (OR operators)
$ mkdir test || cd test


|-|_|-|_|-|_|-|_|-| Send processes to background and foreground |-|_|-|_|-|_|-|_|-|

Ejemplo 1:

$ cat > mi_nota.txt
- Para mandarlo al Background se oprime Ctrl+Z (Eso suspende el proceso) (No con Ctrl+D, eso terminaria el proceso/job)
$ jobs
- Con jobs se listan los procesos corriendo y se puede mandar al foreground segun su numero de trabajo (jon number):
$ fg 1
- De esa manera ya se puede seguir ingresando datos donde se habia dejado el archivo.

Ejemplo 2:

$ google-chrome-stable
^Z
- Y despues se manda al background para seguir trabajando
$ bg 1

Una forma de crear un proceso directamente en Background es con "&"

$ less prueba.txt &


|-|_|-|_|-|_|-|_|-| DNS lookup with Dig |-|_|-|_|-|_|-|_|-|

dig @<dns_address> <url>

Ejemplo:
$ dig @8.8.8.8.8 play.hbomax.com


|-|_|-|_|-|_|-|_|-| Change Time Zone in Red Hat derivatives |-|_|-|_|-|_|-|_|-|

- To show time, date and timezone:
$ date
$ timedatectl

- To change Timezone:
To change the timezone, create the symbolic link /etc/localtime to the appropriate timezone under /usr/share/zoneinfo/:
(/usr/share/zoneinfo contains all the information of all the time zones globally)

$ sudo ln  -sf /usr/share/zoneinfo/America/Bogota /etc/localtime

The flag -s enables creation of a symbolic link, otherwise a hard link is created by default and -f removes an existing destination file, which in this case is /etc/localtime


|-|_|-|_|-|_|-|_|-| reload network connection |-|_|-|_|-|_|-|_|-|

# nmcli connection reload
OR
# systemctl restart NetworkManager


|-|_|-|_|-|_|-|_|-| Creation of tap interface/device |-|_|-|_|-|_|-|_|-|

# ip tuntap add tap0 mode tap
# ip link set dev tap0 up
# ip addr add 192.168.1.1/24 dev tap0


|-|_|-|_|-|_|-|_|-| Creation of dummy interface |-|_|-|_|-|_|-|_|-|

# ip link add dummy1 type dummy
# ip addr 1.1.1.1/24 dev dummy1
# ip link set dummy1 up
